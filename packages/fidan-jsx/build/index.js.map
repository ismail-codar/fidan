{"version":3,"file":"index.js","sources":["../src/events.ts","../src/index.ts","../src/array-map.ts"],"sourcesContent":["type ExpandableElement = HTMLElement & { [key: string]: any };\ntype DelegatedEventHandler = (e: Event, model?: any) => any;\n\nconst eventRegistry = new Set();\n\nfunction lookup(\n  el: ExpandableElement,\n  name: string\n): [DelegatedEventHandler, any?] {\n  let h = el[name],\n    m = el.model,\n    r,\n    p;\n  if (\n    (h === undefined || (h.length > 1 && m === undefined)) &&\n    (p = el.host || el.parentNode)\n  )\n    r = lookup(p, name);\n  return [h !== undefined ? h : r && r[0], m || (r && r[1])];\n}\nfunction eventHandler(e: Event) {\n  const node = (e.composedPath && e.composedPath()[0]) || e.target;\n  const [handler, model] = lookup(node as ExpandableElement, `__${e.type}`);\n\n  // reverse Shadow DOM retargetting\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  return handler && handler(e, model);\n}\n\nexport const delegateEvents = (eventNames: string[]) => {\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!eventRegistry.has(name)) {\n      eventRegistry.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n};\n","import { compute } from \"@fidanjs/runtime\";\n\nexport * from \"./events\";\nexport * from \"./array-map\";\n\nconst nop: any = () => {};\n\nexport const cleanup = nop;\n\nexport const wrap = <T>(fn: (prev?: T) => T) => {\n  debugger;\n  compute(fn);\n};\n\nexport const sample = <T>(fn: () => T) => {\n  return fn();\n};\n\nexport const root = <T>(fn: (dispose: () => void) => T) => {\n  return fn(() => {\n    return null;\n  });\n};\n\nfunction clearAll(\n  parent: Node,\n  current: any,\n  marker?: Node,\n  startNode?: Node | null\n) {\n  if (!marker) return (parent.textContent = \"\");\n  if (Array.isArray(current)) {\n    for (let i = 0; i < current.length; i++) {\n      parent.removeChild(current[i]);\n    }\n  } else if (current != null && current != \"\") {\n    if (startNode !== undefined) {\n      let node = marker.previousSibling,\n        tmp;\n      while (node !== startNode) {\n        tmp = (node as Node).previousSibling;\n        parent.removeChild(node as Node);\n        node = tmp;\n      }\n    } else parent.removeChild(marker.previousSibling as Node);\n  }\n  return \"\";\n}\n\nfunction insertExpression(\n  parent: Node,\n  value: any,\n  current?: any,\n  marker?: Node\n) {\n  if (value === current) return current;\n  parent = (marker && marker.parentNode) || parent;\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\") {\n    if (t === \"number\") value = value.toString();\n    if (marker) {\n      if (value === \"\") clearAll(parent, current, marker);\n      else if (current !== \"\" && typeof current === \"string\") {\n        (marker.previousSibling as Text).data = value;\n      } else {\n        const node = document.createTextNode(value);\n        if (current !== \"\" && current != null) {\n          parent.replaceChild(node, marker.previousSibling as Node);\n        } else parent.insertBefore(node, marker);\n      }\n      current = value;\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = (parent.firstChild as Text).data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    current = clearAll(parent, current, marker);\n  } else if (t === \"function\") {\n    wrap(function() {\n      current = insertExpression(parent, value(), current, marker);\n    });\n  } else if (value instanceof Node) {\n    if (Array.isArray(current)) {\n      if (current.length === 0) {\n        parent.insertBefore(value, marker as any);\n      } else if (current.length === 1) {\n        parent.replaceChild(value, current[0]);\n      } else {\n        clearAll(parent, current, marker);\n        parent.appendChild(value);\n      }\n    } else if (current == null || current === \"\") {\n      parent.insertBefore(value, marker as any);\n    } else {\n      parent.replaceChild(\n        value,\n        (marker && marker.previousSibling) || (parent.firstChild as Node)\n      );\n    }\n    current = value;\n  } else if (Array.isArray(value)) {\n    debugger;\n    // let array = normalizeIncomingArray([], value);\n    // clearAll(parent, current, marker);\n    // if (array.length !== 0) {\n    //   for (let i = 0, len = array.length; i < len; i++) {\n    //     parent.insertBefore(array[i], marker as any);\n    //   }\n    // }\n    // current = array;\n  } else {\n    throw new Error(\"content must be Node, stringable, or array of same\");\n  }\n\n  return current;\n}\n\nexport const insert = (\n  parent: Node,\n  accessor: any,\n  init?: any,\n  marker?: Node\n) => {\n  if (typeof accessor === \"object\") {\n    marker.appendChild(accessor);\n  } else if (typeof accessor === \"function\") {\n    const node = document.createTextNode(\"\");\n    compute(\n      () => {\n        node.data = accessor();\n        if (!node.parentNode) {\n          parent.insertBefore(node, marker);\n        }\n      },\n      () => [accessor]\n    );\n  } else {\n    const node = document.createTextNode(accessor);\n    parent.insertBefore(node, marker);\n  }\n};\n\nexport const spread = (node: HTMLElement, accessor: any) => {\n  if (typeof accessor === \"function\") {\n    accessor(node);\n  } else {\n    debugger;\n  }\n};\n","import { FidanArray, arrayMap } from \"@fidanjs/runtime\";\n\nexport const jsxArrayMap = <T>(\n  arr: FidanArray<T[]>,\n  renderCallback: (data: T) => DocumentFragment,\n  renderMode?: \"reuse\" | \"reconcile\"\n) => {\n  return parentElement => {\n    arrayMap(arr, parentElement, null, renderCallback, renderMode);\n  };\n};\n"],"names":["eventRegistry","Set","eventHandler","e","node","composedPath","target","lookup","el","name","r","p","h","m","model","undefined","length","host","parentNode","Object","defineProperty","configurable","value","handler","fn","compute","parent","accessor","init","marker","appendChild","document","createTextNode","data","insertBefore","eventNames","let","i","l","has","add","addEventListener","arr","renderCallback","renderMode","parentElement","arrayMap"],"mappings":"kCAGMA,EAAgB,IAAIC,IAiB1B,SAASC,EAAaC,OACdC,EAAQD,EAAEE,cAAgBF,EAAEE,eAAe,IAAOF,EAAEG,SAhB5D,SAASC,EACPC,EACAC,OAIEC,EACAC,EAHEC,EAAIJ,EAAGC,GACTI,EAAIL,EAAGM,kBAIAC,IAANH,GAAoBA,EAAEI,OAAS,QAAWD,IAANF,KACpCF,EAAIH,EAAGS,MAAQT,EAAGU,cAEnBR,EAAIH,EAAOI,EAAGF,IACT,MAAOM,IAANH,EAAkBA,EAAIF,GAAKA,EAAE,GAAIG,GAAMH,GAAKA,EAAE,IAI7BH,CAAOH,OAAgCD,6BAG5DA,EAAEG,SAAWF,GACfe,OAAOC,eAAejB,EAAG,SAAU,CACjCkB,cAAc,EACdC,MAAOlB,IAGJmB,GAAWA,EAAQpB,EAAGW,sDCtBPU,GAEtBC,UAAQD,4BAGgBA,UACjBA,2BAGeA,UACfA,oBACE,gCAmGTE,EACAC,EACAC,EACAC,MAEwB,iBAAbF,EACTE,EAAOC,YAAYH,QACd,GAAwB,mBAAbA,EAAyB,KACnCvB,EAAO2B,SAASC,eAAe,IACrCP,qBAEIrB,EAAK6B,KAAON,IACPvB,EAAKc,YACRQ,EAAOQ,aAAa9B,EAAMyB,qBAGxB,CAACF,SAEJ,KACCvB,EAAO2B,SAASC,eAAeL,GACrCD,EAAOQ,aAAa9B,EAAMyB,6BAIPzB,EAAmBuB,GAChB,mBAAbA,GACTA,EAASvB,oCD/GkB+B,OACxBC,IAAIC,EAAI,EAAGC,EAAIH,EAAWnB,OAAQqB,EAAIC,EAAGD,IAAK,KAC3C5B,EAAO0B,EAAWE,GACnBrC,EAAcuC,IAAI9B,KACrBT,EAAcwC,IAAI/B,GAClBsB,SAASU,iBAAiBhC,EAAMP,mCEpCpCwC,EACAC,EACAC,mBAEOC,GACLC,WAASJ,EAAKG,EAAe,KAAMF,EAAgBC"}