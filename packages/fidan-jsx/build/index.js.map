{"version":3,"file":"index.js","sources":["../src/events.ts","../src/index.ts","../src/array-map.ts"],"sourcesContent":["type ExpandableElement = HTMLElement & { [key: string]: any };\ntype DelegatedEventHandler = (e: Event, model?: any) => any;\n\nconst eventRegistry = new Set();\n\nfunction lookup(\n  el: ExpandableElement,\n  name: string\n): [DelegatedEventHandler, any?] {\n  let h = el[name],\n    m = el.model,\n    r,\n    p;\n  if (\n    (h === undefined || (h.length > 1 && m === undefined)) &&\n    (p = el.host || el.parentNode)\n  )\n    r = lookup(p, name);\n  return [h !== undefined ? h : r && r[0], m || (r && r[1])];\n}\nfunction eventHandler(e: Event) {\n  const node = (e.composedPath && e.composedPath()[0]) || e.target;\n  const [handler, model] = lookup(node as ExpandableElement, `__${e.type}`);\n\n  // reverse Shadow DOM retargetting\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  return handler && handler(e, model);\n}\n\nexport const delegateEvents = (eventNames: string[]) => {\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!eventRegistry.has(name)) {\n      eventRegistry.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n};\n","import { compute } from \"@fidanjs/runtime\";\n\nexport * from \"./events\";\nexport * from \"./array-map\";\n\nconst nop: any = () => {};\n\nexport const cleanup = nop;\n\nexport const wrap = <T>(fn: (prev?: T) => T) => {\n  debugger;\n  compute(fn);\n};\n\nexport const sample = <T>(fn: () => T) => {\n  return fn();\n};\n\nexport const root = <T>(fn: (dispose: () => void) => T) => {\n  return fn(() => {\n    return null;\n  });\n};\n\nexport const insert = (parent, accessor) => {\n  if (typeof accessor === \"object\") {\n    parent.appendChild(accessor);\n  } else if (typeof accessor === \"function\") {\n    compute(\n      () => {\n        parent.textContent = accessor();\n      },\n      () => [accessor]\n    );\n  } else {\n    parent.textContent = accessor;\n  }\n};\n","import { FidanArray, arrayMap } from \"@fidanjs/runtime\";\n\nexport const jsxArrayMap = <T>(\n  arr: FidanArray<T[]>,\n  renderCallback: (data: T) => DocumentFragment,\n  renderMode?: \"reuse\" | \"reconcile\"\n) => {\n  return (parentElement, nextElement) => {\n    arrayMap(arr, parentElement, nextElement, renderCallback, renderMode);\n  };\n};\n"],"names":["eventRegistry","Set","eventHandler","e","node","composedPath","target","lookup","el","name","r","p","h","m","model","undefined","length","host","parentNode","Object","defineProperty","configurable","value","handler","fn","compute","parent","accessor","appendChild","textContent","eventNames","let","i","l","has","add","document","addEventListener","arr","renderCallback","renderMode","parentElement","nextElement","arrayMap"],"mappings":"kCAGMA,EAAgB,IAAIC,IAiB1B,SAASC,EAAaC,OACdC,EAAQD,EAAEE,cAAgBF,EAAEE,eAAe,IAAOF,EAAEG,SAhB5D,SAASC,EACPC,EACAC,OAIEC,EACAC,EAHEC,EAAIJ,EAAGC,GACTI,EAAIL,EAAGM,kBAIAC,IAANH,GAAoBA,EAAEI,OAAS,QAAWD,IAANF,KACpCF,EAAIH,EAAGS,MAAQT,EAAGU,cAEnBR,EAAIH,EAAOI,EAAGF,IACT,MAAOM,IAANH,EAAkBA,EAAIF,GAAKA,EAAE,GAAIG,GAAMH,GAAKA,EAAE,IAI7BH,CAAOH,OAAgCD,6BAG5DA,EAAEG,SAAWF,GACfe,OAAOC,eAAejB,EAAG,SAAU,CACjCkB,cAAc,EACdC,MAAOlB,IAGJmB,GAAWA,EAAQpB,EAAGW,sDCtBPU,GAEtBC,UAAQD,4BAGgBA,UACjBA,2BAGeA,UACfA,oBACE,gCAIYE,EAAQC,GACL,iBAAbA,EACTD,EAAOE,YAAYD,GACU,mBAAbA,EAChBF,qBAEIC,EAAOG,YAAcF,sBAEjB,CAACA,KAGTD,EAAOG,YAAcF,mCDDMG,OACxBC,IAAIC,EAAI,EAAGC,EAAIH,EAAWd,OAAQgB,EAAIC,EAAGD,IAAK,KAC3CvB,EAAOqB,EAAWE,GACnBhC,EAAckC,IAAIzB,KACrBT,EAAcmC,IAAI1B,GAClB2B,SAASC,iBAAiB5B,EAAMP,mCEpCpCoC,EACAC,EACAC,mBAEQC,EAAeC,GACrBC,WAASL,EAAKG,EAAeC,EAAaH,EAAgBC"}